{"version":3,"file":"vue.js","sources":["../src/utils.js","../src/observer/array.js","../src/observer/dep.js","../src/observer/index.js","../src/state.js","../src/compiler/parser.js","../src/compiler/generator.js","../src/compiler/index.js","../src/observer/scheduler.js","../src/observer/watcher.js","../src/vdom/patch.js","../src/lifecycle.js","../src/init.js","../src/vdom/create-element.js","../src/render.js","../src/global-api/index.js","../src/index.js"],"sourcesContent":["// 此处放所有的工具方法\n\n\nexport function isObject(obj) {\n    return typeof obj === 'object' && obj !== null\n}\nconst LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'mounted',\n    'beforeUpdate',\n    'updated'\n]\nlet strats = {};\nfunction mergeHook(parentVal,childVal){ // []\n    if(childVal){ // 如果 孩子有值 \n        if(parentVal){ // 父亲有值 就直接拼接\n            return parentVal.concat(childVal)\n        }else{ // 如果孩子有值父亲没值 就将孩子包装成数组\n            return [childVal] // Vue.options.beforeCreate = [childVal]\n        }\n    }else{\n        return parentVal; // 直接返回父亲，因为没有孩子  \n    }\n}\nLIFECYCLE_HOOKS.forEach(hook=>{\n    strats[hook] = mergeHook\n})\nexport function mergeOptions(parent,child){ // {...parent,...child}  {a:1.b:2}  {a:{a:{b:2}}}\n    const options = {}\n    // 如果父亲和儿子里都有一个属性 这个属性不冲突 \n    for(let key in parent){ // 处理父亲的所有属性\n        mergeField(key);\n    }\n    for(let key in child){ // 处理儿子的所有属性，如果父亲有的值 在第一个循环中就已经处理了\n        if(!parent.hasOwnProperty(key)){\n            mergeField(key);\n        }\n    }\n    function mergeField(key){\n        // 两个组件间 data是函数 \n\n        // 写代码时很忌讳 各种if else if else \n\n        // 策略模式 根据不同的属性 调用不同的策略  \n        if(strats[key]){\n            // 这里就包含了 mergeHook的逻辑\n            options[key] = strats[key](parent[key],child[key])\n        }else if(isObject(parent[key]) && isObject(child[key])){\n            options[key] = Object.assign(parent[key],child[key])\n        }else{\n            if(child[key] == null){\n                options[key] = parent[key];\n            }else{\n                options[key] = child[key]; // 用儿子的值 直接覆盖掉 父亲的值\n            }\n        }\n    } // 面试时 经常会提到对象间的合并\n    return options\n}\n","let oldArrayMethods = Array.prototype; // 获取数组原型上的方法\n\n// 创建一个全新的对象 可以找到数组原型上的方法，而且修改对象时不会影响原数组的原型方法\nexport let arrayMethods = Object.create(oldArrayMethods);\n\nlet methods = [ // 这七个方法都可以改变原数组\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'sort',\n  'reverse',\n  'splice'\n]\nmethods.forEach(method => {\n  arrayMethods[method] = function (...args) { // 函数劫持 AOP\n    // 当用户调用数组方法时 会先执行我自己改造的逻辑 在执行数组默认的逻辑\n    const ob = this.__ob__;\n    let result = oldArrayMethods[method].apply(this, args);\n    let inserted;\n    // push unshift splice 都可以新增属性  （新增的属性可能是一个对象类型）\n    // 内部还对数组中引用类型也做了一次劫持  [].push({name:'hm'})\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break;\n      case 'splice': // 也是新增属性  可以修改 可以删除  [].splice(arr,1,'div')\n        inserted = args.slice(2);\n        break;\n      default:\n        break;\n    }\n    inserted && ob.observeArray(inserted);\n    return result;\n  }\n})\n\n\n\n\n","let id = 0\n\nclass Dep {\n  constructor() {\n    this.id = id++;\n    this.subs = [];\n  }\n\n  depend() {\n    // 1. 让dep 记住watcher\n    // 2. 让watcher 记住dep 双向记忆\n    Dep.target.addDep(this); // 让watcher 存储dep\n    this.addSub(Dep.target)\n  }\n\n  addSub(watcher) {\n    this.subs.push(watcher);\n  }\n\n  notify() {\n    this.subs.forEach(watcher => watcher.update())\n  }\n}\n\nDep.target = null; // 默认target是空的\nconst stack = [];\n\nexport function pushTarget(watcher) {\n  Dep.target = watcher\n  //  stack.push(watcher) // []\n}\n\nexport function popTarget() {\n  Dep.target = null;\n  //   stack.pop();\n  //   Dep.target = stack[stack.length-1];\n}\n\n\nexport default Dep;\n// dep 和 watcher 是一个多对多的关系\n// 每个属性 都有一个dep属性 ，dep 存放着watcher  一个dep中有多个watcher ，一个watcher可能被多个属性所依赖\n","import {isObject} from '../utils.js';\nimport {arrayMethods} from './array'\nimport Dep from './dep.js';\n\n// es6的类来实现的\nclass Observer {\n  constructor(data) {\n    // 对数组索引进行拦截 性能差而且直接更改索引的方式并不多\n    Object.defineProperty(data, '__ob__', { // __ob__ 是一个响应式饿表示 对象数组都有\n      enumerable: false, // 不可枚举\n      configurable: false,\n      value: this\n    })\n    // data.__ob__ = this; // 相当于在数据上可以获取到__ob__这个属性 指代的是Observer的实例\n    if (Array.isArray(data)) {\n      // vue如何对数组进行处理呢？ 数组用的是重写数组的方法  函数劫持\n      // 改变数组本身的方法我就可以监控到了\n      data.__proto__ = arrayMethods; // 通过原型链 向上查找的方式\n      // [{a:1}]    => arr[0].a = 100\n      this.observeArray(data);\n    } else {\n      this.walk(data); // 可以对数据一步一步的处理\n    }\n  }\n\n  observeArray(data) {\n    for (let i = 0; i < data.length; i++) {\n      observe(data[i]);// 检测数组的对象类型\n    }\n  }\n\n  walk(data) {\n    Object.keys(data).forEach(key => {\n      defineReactive(data, key, data[key]);// 定义响应式的数据变化\n    })\n  }\n}\n\n// function data() {\n//   return {\n//     msg: '23',\n//     info: {\n//\n//     }\n//   }\n// }\n\n// vue2 的性能 递归重写get和set  proxy\n// 闭包的试用场景\n\n// get的时候，收集依赖\n// 如果当前数据在组件里面使用到了，当前组件的实例/更新方法收集到dep里面的subs数组里面\n// 修改数据的时候，会触发set方法，把收集到依赖，进行更新\n// vue2里面，更新粒度是组件级别\n\nfunction defineReactive(data, key, value) {\n  observe(value); // 如果传入的值还是一个对象的话 就做递归循环检测\n  let dep = new Dep(); // msg.dep =[watcher]  age.dep = [watcher]  // 渲染watcher中.deps [msg.dep,age.dep]\n  Object.defineProperty(data, key, {\n    get() {\n      // 这里会有取值的操作  ，给这个属性增加一个dep，这个dep 要和刚才我放到全局变量的上的watcher 做一个对应关系\n      // 添加观察者\n      // 当前数据被哪个组件使用到了，当前组件的更新方法添加到观察者\n      if (Dep.target) {\n        dep.depend(); // 让这个dep 去收集watcher\n      }\n      return value\n    },\n    set(newValue) {\n      if (newValue == value) return;\n      observe(newValue); // 监控当前设置的值，有可能用户给了一个新值\n      value = newValue;\n\n      // 当我们更新数据后 要把当前自己对应的watcher 去重新执行以下\n      dep.notify();\n    }\n  })\n}\n\nexport function observe(data) {\n  // 对象就是使用defineProperty 来实现响应式原理\n  // 如果这个数据不是对象 或者是null 那就不用监控了\n  if (!isObject(data)) {\n    return;\n  }\n  if (data.__ob__ instanceof Observer) { // 防止对象被重复观测\n    return;\n  }\n\n  // 对数据进行defineProperty\n  return new Observer(data); // 可以看到当前数据是否被观测过\n}\n","import {observe} from './observer/index.js'\n\nexport function initState(vm) {\n  const opts = vm.$options;\n  if (opts.props) {\n    initProps(vm);\n  }\n  if (opts.methods) {\n    initMethod(vm);\n  }\n  if (opts.data) {\n    initData(vm);\n  }\n  // computed ... watch\n}\n\nfunction initProps() {\n}\n\nfunction initMethod() {\n}\n\nfunction proxy(target, property, key) {\n  Object.defineProperty(target, key, {\n    get() {\n      return target[property][key];\n    },\n    set(newValue) {\n      target[property][key] = newValue\n    }\n  })\n}\n\nfunction initData(vm) {\n  // 数据响应式原理\n  let data = vm.$options.data; // 用户传入的数据\n  // vm._data 就是检测后的数据了\n  data = vm._data = typeof data === 'function' ? data.call(vm) : data;\n  // 观测数据\n  // 将数据全部代理到vm的实例上\n\n  // this.msg\n  // this.data.msg\n  for (let key in data) {\n    proxy(vm, '_data', key);\n  }\n  observe(data); // 观测这个数据\n}\n","//              字母a-zA-Z_ - . 数组小写字母 大写字母\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; // 标签名\n// ?:匹配不捕获   <aaa:aaa>\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;\n// startTagOpen 可以匹配到开始标签 正则捕获到的内容是 (标签名)\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 标签开头的正则 捕获的内容是标签名\n// 闭合标签 </xxxxxxx>\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`); // 匹配标签结尾的 </div>\n// <div aa   =   \"123\"  bb=123  cc='123'\n// 捕获到的是 属性名 和 属性值 arguments[1] || arguments[2] || arguments[2]\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配属性的\n// <div >   <br/>\nconst startTagClose = /^\\s*(\\/?)>/; // 匹配标签结束的 >\n// 匹配动态变量的  +? 尽可能少匹配\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\n\nexport function parseHTML(html) {\n  // ast 树 表示html的语法\n  let root; // 树根\n  let currentParent;\n  let stack = []; // 用来判断标签是否正常闭合  [div]  解析器可以借助栈型结构\n  // <div id=\"app\" style=\"color:red\"><span>    helloworld {{msg}}   </span></div>\n\n  // vue2.0 只能有一个根节点 必须是html 元素\n\n  // 常见数据结构 栈 队列 数组 链表 集合 hash表 树\n  function createASTElement(tagName, attrs) {\n    return {\n      tag: tagName,\n      attrs,\n      children: [],\n      parent: null,\n      type: 1 // 1 普通元素  3 文本\n    }\n  }\n\n  // console.log(html)\n  function start(tagName, attrs) { // 开始标签 每次解析开始标签 都会执行此方法\n    let element = createASTElement(tagName, attrs);\n    if (!root) {\n      root = element; // 只有第一次是根\n    }\n    currentParent = element;\n    stack.push(element);\n  }\n\n  // <div> <span></span> hello world</div>   [div,span]\n  function end(tagName) { // 结束标签  确立父子关系\n    let element = stack.pop();\n    currentParent = stack[stack.length - 1];\n    if (currentParent) {\n      element.parent = currentParent;\n      currentParent.children.push(element);\n    }\n  }\n\n  function chars(text) { // 文本\n    text = text.replace(/\\s/g, '');\n    if (text) {\n      currentParent.children.push({\n        type: 3,\n        text\n      })\n    }\n  }\n\n  // 根据 html 解析成树结构  </span></div>\n  while (html) {\n    let textEnd = html.indexOf('<');\n    if (textEnd == 0) {\n      const startTageMatch = parseStartTag();\n\n      if (startTageMatch) {\n        // 开始标签\n        start(startTageMatch.tagName, startTageMatch.attrs)\n      }\n      const endTagMatch = html.match(endTag);\n\n      if (endTagMatch) {\n        advance(endTagMatch[0].length);\n        end(endTagMatch[1])\n      }\n      // 结束标签\n    }\n\n    // 如果不是0 说明是文本\n    let text;\n    if (textEnd > 0) {\n      text = html.substring(0, textEnd); // 是文本就把文本内容进行截取\n      chars(text);\n    }\n    if (text) {\n      advance(text.length); // 删除文本内容\n    }\n  }\n\n  function advance(n) {\n    html = html.substring(n);\n  }\n\n  function parseStartTag() {\n    const start = html.match(startTagOpen); // 匹配开始标签\n    if (start) {\n      const match = {\n        tagName: start[1], // 匹配到的标签名\n        attrs: []\n      }\n      advance(start[0].length);\n      let end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push({name: attr[1], value: attr[3] || attr[4] || attr[5]})\n      }\n\n      if (end) {\n        advance(end[0].length);\n        return match;\n      }\n    }\n  }\n\n  return root;\n\n}\n","const defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\n\nfunction genProps(attrs) {  // {id:'app',style:{color:red}}\n  let str = ''\n  for (let i = 0; i < attrs.length; i++) {\n    let attr = attrs[i]; // 取到每一个属性\n    if (attr.name === 'style') {\n      let obj = {}; //  color:red;background:green\n      attr.value.split(';').forEach(item => {\n        let [key, value] = item.split(':');\n        obj[key] = value;\n      });\n      attr.value = obj; // 将原来的字符串换成了 刚才格式化后的对象\n    }\n    str += `${attr.name}:${JSON.stringify(attr.value)},`\n  }\n  return `{${str.slice(0, -1)}}`;\n}\n\nfunction gen(node) {\n  if (node.type === 1) {\n    return generate(node)\n  } else {\n    // 文本的处理\n    let text = node.text;\n    if (!defaultTagRE.test(text)) {  // 有变量 {{}}\n      return `_v(${JSON.stringify(text)})` // _v('helloworld')\n    } else {\n      let tokens = []; // 每次正则使用过后 都需要重新指定 lastIndex  aaaab\n      let lastIndex = defaultTagRE.lastIndex = 0;\n      let match, index;\n      while (match = defaultTagRE.exec(text)) {\n        index = match.index;\n        // 通过 lastIndex,ndex\n        tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n        tokens.push(`_s(${match[1].trim()})`);\n        lastIndex = index + match[0].length\n      }\n      if (lastIndex < text.length) {\n        tokens.push(JSON.stringify(text.slice(lastIndex)));\n      }\n      return `_v(${tokens.join('+')})`\n    }\n    // helloworld {{  msg  }}  aa {{bb}}  aaa   => _v('helloworld'+_s(msg)+\"aa\" + _s(bb))\n  }\n}\n\nfunction genChildren(el) { // <div><span></span> hello</div>\n  const children = el.children;\n  if (children) {\n    return children.map(c => gen(c)).join(',')\n  } else {\n    return false\n  }\n}\n\nexport function generate(el) {\n  let children = genChildren(el); // 生成孩子字符串\n  let code = `_c(\"${el.tag}\",${\n    el.attrs.length ? `${genProps(el.attrs)}` : undefined\n  }${\n    children ? `,${children}` : ''\n  })`;\n\n  return code;\n}\n\n// 语法级的编译\n","import {parseHTML} from './parser.js'\nimport {generate} from './generator.js';\nexport function compileToFunctions(template){\n    // console.log(template)\n    // 实现模板的编译\n    let ast = parseHTML(template);\n\n    // ast语法树\n\n    // 代码生成\n    // template => render 函数\n\n    /**\n     * react\n     * render(){\n        * with(this){\n        *  return _c('div',{id:app,style:{color:red}},_c('span',undefined,_v(\"helloworld\"+_s(msg)) ))\n        * }\n     * }\n     *\n     */\n    // 核心就是字符串拼接\n    let code = generate(ast); // 代码生成 =》 拼接字符串\n\n    code = `with(this){ \\r\\nreturn ${code} \\r\\n}`;\n\n    let render = new Function(code); // 相当于给字符串变成了函数\n\n\n    // 注释节点 自闭和标签 事件绑定 @click  class slot插槽\n\n    return render;\n    // 模板编译原理\n    // 1.先把我们的代码转化成ast语法树\n    // （1）  parser 解析  (正则)\n    // 2.标记静态树  （2） 树得遍历标记 markup  只是优化\n    // 3.通过ast产生的语法树 生成 代码 =》 render函数  codegen\n}\n\n\n","let has = {}; // vue源码里有的时候去重用的是set 有的时候用的是对象来实现的去重\nlet queue = [];\n\n// 这个队列是否正在等待更新\nfunction flushSchedulerQueue() {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i].run();\n  }\n  queue = [];\n  has = {};\n}\n\n\nexport function queueWatcher(watcher) {\n  const id = watcher.id;\n\n  if (has[id] == null) {\n    has[id] = true; // 如果没有注册过这个watcher，就注册这个watcher到队列中，并且标记为已经注册\n    queue.push(watcher);\n    nextTick(flushSchedulerQueue); // flushSchedulerQueue 调用渲染watcher\n  }\n}\n\nlet callbacks = []; // [flushSchedulerQueue,fn]\nlet pending = false;\n\nfunction flushCallbacksQueue() {\n  callbacks.forEach(fn => fn());\n  pending = false;\n}\n\nexport function nextTick(fn) {\n  callbacks.push(fn); // 防抖\n  if (!pending) { // true  事件环的概念 promise mutationObserver setTimeout setImmediate\n    setTimeout(() => {\n      flushCallbacksQueue();\n    }, 0);\n    pending = true\n  }\n}\n","import {pushTarget, popTarget} from \"./dep\";\nimport {queueWatcher} from \"./scheduler\";\n\nlet id = 0; // 做一个watcher 的id 每次创建watcher时 都有一个序号\n// 目前写到这里 只有一个watcher 渲染watchrer，只要视图中使用到了这个属性，而且属性变化了就要更新视图\n\nclass Watcher {\n  // vm >> 组件实例\n  // exprOrFn >> 组件的更新方法\n  constructor(vm, exprOrFn, cb, options) {\n    this.vm = vm;\n    this.exprOrFn = exprOrFn; // 组件更新的方法\n    this.cb = cb;\n    this.options = options;\n    this.deps = []; // 这个watcher会存放所有的dep\n    this.depsId = new Set();\n    if (typeof exprOrFn == 'function') {\n      this.getter = exprOrFn; // 组件更新的方法\n    }\n    this.id = id++;\n    this.get();\n  }\n\n  run() {\n    this.get(); // 重新渲染\n  }\n\n  get() {\n    // 1.是先把渲染watcher 放到了 Dep.target上\n    // 2.this.getter()  是不是去页面取值渲染  就是调用defineProperty的取值操作\n    // 3.我就获取当前全局的Dep.target,每个属性都有一个dep 取值是就将Dep.target 保留到当前的dep中\n    // 4.数据变化 通知watcher 更新\n\n\n    // 把当前的wathcer，添加到Dep.target上\n    pushTarget(this); // 在取值之前 将watcher先保存起来\n    this.getter(); // 这句话就实现了视图的渲染  > 读取数据 > 触发当前数据的get方法\n    popTarget(); // 删掉watcher\n    // Vue是组件级别更新的\n  }\n\n  addDep(dep) {\n    let id = dep.id;\n    if (!this.depsId.has(id)) {\n      this.depsId.add(id);\n      this.deps.push(dep);\n      dep.addSub(this); // 让当前dep 订阅这个watcher\n    }\n  }\n\n  update() { // 更新原理\n    queueWatcher(this); // 将watcher存储起来\n    // this.get();  // 以前调用get方法是直接更新视图\n  }\n}\n\n\nexport default Watcher\n","export function patch(oldVnode, newVnode) {\n  const isRealElement = oldVnode.nodeType;\n  if (isRealElement) {\n    // 真实元素\n    const oldElm = oldVnode;\n    const parentElm = oldElm.parentNode;\n    let el = createElm(newVnode);\n    parentElm.insertBefore(el, oldElm.nextSibling)\n    parentElm.removeChild(oldElm);\n    return el; // 渲染的真实dom\n  } else {\n    // dom diff 算法  同层比较 （默认想完整比对一棵树 O(n^3)）  O(n)\n    // 不需要跨级比较\n\n    // 两棵树 要先比较树根一不一样，再去比儿子长的是否一样\n\n    if (oldVnode.tag !== newVnode.tag) { // 标签名不一致 说明是两个不一样的节点\n      oldVnode.el.parentNode.replaceChild(createElm(newVnode), oldVnode.el);\n    }\n    // 标签一致 div  都是文本 tag = undefined\n\n    if (!oldVnode.tag) { // 如果是文本 文本变化了 直接用新的文本替换掉老的文本\n      if (oldVnode.text !== newVnode.text) {\n        oldVnode.el.textContent = newVnode.text;\n      }\n    }\n    // 一定是标签了 而且标签一致\n    // 需要复用老的节点 替换掉老的属性\n    let el = newVnode.el = oldVnode.el;\n    // 更新属性  diff 属性\n    updateProperties(newVnode, oldVnode.data); // 此时属性就更新完毕了 当前的树根已经完成了\n\n    // 比对孩子节点\n    let oldChildren = oldVnode.children || []; // 老的孩子\n    let newChildren = newVnode.children || []; // 新的孩子\n\n    // 新老都有孩子 那就比较 diff核心\n    // 老的有孩子 新的没孩子 直接删除\n    // 新的有孩子  老的没孩子 直接插入\n\n    if (oldChildren.length > 0 && newChildren.length > 0) {\n      // diff  两个人都有儿子 ** 这里要不停的去比较孩子节点\n      updateChildren(el, oldChildren, newChildren);\n      // 通过比较老孩子和新孩子 操作el中的儿子\n\n    } else if (oldChildren.length > 0) {\n      el.innerHTML = '';\n    } else if (newChildren.length > 0) {\n      for (let i = 0; i < newChildren.length; i++) {\n        let child = newChildren[i]; // 拿到一个个的孩子\n        el.appendChild(createElm(child)); // 浏览器会自动优化\n      }\n    }\n    return el;\n  }\n}\n\nfunction isSameVnode(oldVnode, newVnode) {\n  return (oldVnode.key == newVnode.key) && (oldVnode.tag === newVnode.tag);\n}\n\nfunction updateChildren(parent, oldChildren, newChildren) {\n  // Vue2.0 使用双指针的方式 来进行比对\n  // v-for 要有key  key可以标识元素 是否发生变化 前后的key相同则可以复用这个元素\n\n  let oldStartIndex = 0; // 老的开始的索引\n  let oldStartVnode = oldChildren[0]; // 老的开始\n  let oldEndIndex = oldChildren.length - 1; // 老的尾部索引\n  let oldEndVnode = oldChildren[oldEndIndex]; // 获取老的孩子的最后一个\n\n  let newStartIndex = 0; // 老的开始的索引\n  let newStartVnode = newChildren[0]; // 老的开始\n  let newEndIndex = newChildren.length - 1; // 老的尾部索引\n  let newEndVnode = newChildren[newEndIndex]; // 获取老的孩子的最后一个\n\n  function makeIndexByKey(children) { // 只需要创建一次 映射表\n    let map = {};\n    children.forEach((item, index) => {\n      map[item.key] = index;\n    })\n    return map\n  }\n\n  let map = makeIndexByKey(oldChildren); // 根据老的孩子的key 创建一个映射表\n  // 1方案1 先开始从头部进行比较  O(n)  优化向后插入的逻辑\n  // 比较时 就是采用最短的进行比较，剩下的要不是删除要么是增加\n  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n    // 如何判断 两个虚拟节点是否一致 就是用key + type 进行判断\n    if (!oldStartVnode) {\n      oldStartVnode = oldChildren[++oldStartIndex];\n    } else if (!oldEndVnode) {\n      oldEndVnode = oldChildren[--oldEndIndex]\n    } else if (isSameVnode(oldStartVnode, newStartVnode)) {\n      //标签和key一致 但是 元素可能属性不一致\n      patch(oldStartVnode, newStartVnode); //自身属性 +  递归比较\n      oldStartVnode = oldChildren[++oldStartIndex];\n      newStartVnode = newChildren[++newStartIndex];\n      //  指针不停的在动\n    } else if (isSameVnode(oldEndVnode, newEndVnode)) {\n      // 2 方案2  从尾部开始比较 如果头部不一致 开始尾部比较， 优化向前插入\n      patch(oldEndVnode, newEndVnode);\n      oldEndVnode = oldChildren[--oldEndIndex]; // 移动尾部指针\n      newEndVnode = newChildren[--newEndIndex];\n    } else if (isSameVnode(oldStartVnode, newEndVnode)) { // 正序  和 倒叙  reverst sort\n      // 3方案3 头不一样 尾不一样  头移尾  倒序操作\n      patch(oldStartVnode, newEndVnode);\n      parent.insertBefore(oldStartVnode.el, oldEndVnode.el.nextSibling); // 具备移动性\n      oldStartVnode = oldChildren[++oldStartIndex];\n      newEndVnode = newChildren[--newEndIndex];\n    } else if (isSameVnode(oldEndVnode, newStartVnode)) { // 老的尾 和新的头比对\n      patch(oldEndVnode, newStartVnode);\n      parent.insertBefore(oldEndVnode.el, oldStartVnode.el)\n      oldEndVnode = oldChildren[--oldEndIndex];\n      newStartVnode = newChildren[++newStartIndex];\n    } else {\n      // 乱序比对  最终处理\n      let moveIndex = map[newStartVnode.key];\n      if (moveIndex == undefined) { // 是一个新元素 ，应该添加进去\n        parent.insertBefore(createElm(newStartVnode), oldStartVnode.el)\n      } else {\n        let moveVnode = oldChildren[moveIndex];\n        oldChildren[moveIndex] = null; // 占位 如果直接删除 可能会导致数组塌陷  [a,b,null,d]\n\n        // 比对当前这两个元素属性和儿子\n        patch(moveVnode, newStartVnode);\n        parent.insertBefore(moveVnode.el, oldStartVnode.el);\n      }\n      newStartVnode = newChildren[++newStartIndex]; // 移动新的指针\n    }\n\n  }\n  if (newStartIndex <= newEndIndex) {\n    for (let i = newStartIndex; i <= newEndIndex; i++) {\n      // appendChild   =  insertBefore null  js原生操作\n      let ele = newChildren[newEndIndex + 1] == null ? null : newChildren[newEndIndex + 1].el\n      parent.insertBefore(createElm(newChildren[i]), ele);\n      // parent.appendChild(createElm(newChildren[i]))\n    }\n  }\n  if (oldStartIndex <= oldEndIndex) { // 说明新的已经循环完毕了 老的有剩余 剩余就是不要的\n    for (let i = oldStartIndex; i <= oldEndIndex; i++) {\n      let child = oldChildren[i];\n      if (child != null) {\n        parent.removeChild(child.el);\n      }\n    }\n  }\n\n  // 没有key 就直接比较类型，如果类型一样就复用 （隐藏的问题是儿子可能都需要重新创建）\n  // 循环时尽量采用唯一的标识 作为key 如果用索引（例如倒叙 会采用索引来复用，不够准确） 如果是静态数据 （你爱用啥用啥）\n\n\n}\n\nexport function createElm(vnode) { // 需要递归创建\n  let {tag, children, data, key, text} = vnode;\n  if (typeof tag == 'string') {\n    // 元素 // 将虚拟节点和真实节点做一个映射关系 （后面diff时如果元素相同直接复用老元素 ）\n    vnode.el = document.createElement(tag);\n    updateProperties(vnode); // 跟新元素属性\n    children.forEach(child => {\n      // 递归渲染子节点 将子节点 渲染到父节点中\n      vnode.el.appendChild(createElm(child));\n    });\n  } else {\n    // 普通的文本\n    vnode.el = document.createTextNode(text);\n  }\n  return vnode.el\n}\n\nfunction updateProperties(vnode, oldProps = {}) {\n\n  // 需要比较 vnode.data 和 oldProps的差异\n\n  let el = vnode.el;\n  let newProps = vnode.data || {};\n  // 获取老的样式和新的样式的差异 如果新的上面丢失了属性 应该在老的元素上删除掉\n  let newStyle = newProps.style || {};\n  let oldStyle = oldProps.style || {};\n\n  for (let key in oldStyle) {\n    if (!newStyle[key]) {\n      el.style[key] = ''; // 删除之前的样式\n    }\n  }\n  for (let key in oldProps) {\n    if (!newProps[key]) { // 此时的元素一是以前\n      el.removeAttribute(key);\n    }\n  }\n\n  // 其他情况直接用新的值覆盖掉老的值即可\n  for (let key in newProps) {\n    if (key == 'style') {\n      for (let styleName in newProps.style) { // {color:red,background:green}\n        el.style[styleName] = newProps.style[styleName]\n      }\n      // 浏览器重新渲染也会看值是否变化\n    }\n    // event\n    else {\n      el.setAttribute(key, newProps[key]);\n    }\n  }\n}\n","import Watcher from './observer/watcher';\nimport {patch} from './vdom/patch';\n\nexport function lifeCycleMixin(Vue) {\n  Vue.prototype._update = function (vnode) {\n    const vm = this;\n    // 将虚拟节点 变成 真实节点 替换掉$el\n    // 后续 dom diff 也会执行此方法\n    vm.$el = patch(vm.$el, vnode);\n\n  }\n}\n\nexport function mountComponent(vm, el) {\n  // Vue在渲染的过程中 会创建一个 所谓的“渲染watcher ” 只用来渲染的\n  // watcher就是一个回调 每次数据变化 就会重新执行watcher\n  // Vue是不是MVVM框架\n  callHook(vm, 'beforeMount')\n  // 渲染界面\n  const updateComponent = () => {\n    // 内部会调用刚才我们解析后的render方法 =》 vnode\n    // _render => options.render 方法\n    // _update => 将虚拟dom 变成真实dom 来执行\n    console.log('update')\n    // render函数返回当前组件的虚拟dom结构\n    // _update进行新旧虚拟dom的对比\n    vm._update(vm._render());\n  }\n\n  // 每次数据变化 就执行 updateComponent 方法 进行更新操作\n  new Watcher(vm, updateComponent, () => {\n  }, true);\n\n  callHook(vm, 'mounted');\n\n\n  // vue 响应式数据的规则 数据变了 视图会刷新\n}\n\n\nexport function callHook(vm, hook) { // vm.$options\n  let handlers = vm.$options[hook]; // 典型的发布订阅模式\n  if (handlers) {\n    for (let i = 0; i < handlers.length; i++) { // [fn,fn,fn]\n      handlers[i].call(vm); // 所有的生命周期的this 指向的都是当前的实例\n    }\n  }\n}\n","import {initState} from './state';\nimport {compileToFunctions} from './compiler/index';\nimport {mountComponent, callHook} from './lifecycle.js'\nimport {mergeOptions} from './utils';\nimport {nextTick} from './observer/scheduler';\n\nexport function initMixin(Vue) {\n\n  // 传入的构造函数的原型上添加方法\n  Vue.prototype._init = function (options) {\n    // Vue的内部 $options 就是用户传递的所有参数\n    const vm = this;\n    // 这个options 就包含了用户创建实例时传入的所有属性 Vue.options\n    vm.$options = mergeOptions(vm.constructor.options, options); // 用户传入的参数\n\n    callHook(vm, 'beforeCreate') // 调用生命周期函数\n    initState(vm); // 初始化状态 data/methods/props/computed/watcher/provide/inject\n\n    callHook(vm, 'created') // 执行了created函数\n    // 需要通过模板进行渲染\n    if (vm.$options.el) { // 用户传入了el属性\n      vm.$mount(vm.$options.el)\n    }\n  }\n  Vue.prototype.$mount = function (el) { // 可能是字符串 也可以传入一个dom对象\n    const vm = this;\n    el = vm.$el = document.querySelector(el); // 获取el属性\n\n    // 如果同时传入 template 和render  默认会采用render 抛弃template，如果都没传就使用id=\"app\"中的模板\n    const opts = vm.$options;\n\n    if (!opts.render) {\n      let template = opts.template;\n      if (!template && el) { // 应该使用外部的模板\n        template = el.outerHTML;\n        console.log(template)\n      }\n\n      const render = compileToFunctions(template);\n      opts.render = render; // render函数执行返回一个当前组件的虚拟dom结构\n    }\n\n    // 走到这里说明不需要编译了 ，因为用户传入的就是 一个render函数\n\n    mountComponent(vm, el); // 组件的挂载流程\n  }\n\n}\n\n","export function createTextVNode(text) {\n    return vnode(undefined, undefined, undefined, undefined, text);\n}\nexport function createElement(tag, data = {}, ...children) {\n    // vue中的key 不会作为属性传递给组件\n\n    \n    return vnode(tag, data, data.key, children)\n}\n// 虚拟节点是 产生一个对象 用来描述dom结构 增加自定义属性\n// ast 他是描述 dom语法的 \nfunction vnode(tag, data, key, children, text) {\n    return {\n        tag,\n        data,\n        key,\n        children,\n        text,\n    }\n}","import {createTextVNode, createElement} from './vdom/create-element'\n\nexport function renderMixin(Vue) {\n  Vue.prototype._v = function (text) {\n    // 创建文本的虚拟及诶点\n    return createTextVNode(text)\n  }\n  Vue.prototype._c = function () {\n    return createElement(...arguments);\n  }\n  Vue.prototype._s = function (val) {\n    // 判断当前这个值是不是对象 ，如果是对象 直接转换成字符串 ，防止页面出现[object Object]\n    return val == null ? '' : (typeof val === 'object' ? JSON.stringify(val) : val);\n  }\n  Vue.prototype._render = function () {\n    // 调用我们自己实现的render方法\n\n    const vm = this;\n    const {render} = vm.$options;\n\n\n    let vnode = render.call(vm); // _c _c  _s\n    return vnode\n  }\n}\n","// Vue.directive Vue.filter Vue.component\nimport {mergeOptions} from '../utils'\n\nexport function initGlobalAPI(Vue) { // 全局api 肯定接受很多参数\n  Vue.options = {}; // 所有的全局api 用户传递的参数 都会绑定到这个对象中\n\n  // 提取公共的方法 逻辑，通过此方法混合到每个实例中\n\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    console.log(this.options)\n  }\n}\n","import {initMixin} from './init';\nimport {renderMixin} from './render.js';\nimport {lifeCycleMixin} from './lifecycle';\nimport {initGlobalAPI} from './global-api/index'\nimport {nextTick} from './observer/scheduler';\n\n// 1、\n\n\n// 构造函数或者类\nfunction Vue(options) {\n  console.log(options)\n  // 内部要进行初始化的操作\n  this._init(options); // 初始化操作\n}\n\n// 原型模式\ninitMixin(Vue); // 添加原型的方法\nrenderMixin(Vue);\nlifeCycleMixin(Vue);\n\n\n// initGlobalApi 给构造函数来扩展全局的方法\ninitGlobalAPI(Vue);\nVue.prototype.$nextTick = nextTick\n\n\n// ----------------------diff----------------------------\n// diff 是比较两个树的差异 （虚拟dom）  把前后的dom节点渲染成虚拟dom，通过虚拟节点比对,找到差异，更新真实dom节点\n// import {compileToFunctions} from './compiler/index';\n// import {createElm,patch} from './vdom/patch'\n// let vm1 = new Vue({data:{name:'zf'}});\n// let vm2 = new Vue({data:{name:'jw'}});\n//\n// let render1 = compileToFunctions(`<div>\n//     <li key=\"A\">A</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//     <li key=\"D\">D</li>\n// </div>`);\n// let oldVnode = render1.call(vm1);\n//\n// let realElement = createElm(oldVnode);\n// document.body.appendChild(realElement);\n//\n//\n// let render2 = compileToFunctions(`<div>\n//     <li key=\"C\">C</li>\n//     <li key=\"D\">D</li>\n//     <li key=\"M\">M</li>\n//     <li key=\"E\">E</li>\n// </div>`);\n// let newVnode = render2.call(vm2);\n// // 没有虚拟dom 和 diff算法时  直接重新渲染 强制重新更新页面（没有复用老的节点），\n// // diff 算法 而是先不对差异 在进行更新\n// setTimeout(() => {\n//     patch(oldVnode,newVnode); // 虚拟节点之间的比对\n// }, 1000);\n\n\nexport default Vue;\n"],"names":["isObject","obj","LIFECYCLE_HOOKS","strats","mergeHook","parentVal","childVal","concat","forEach","hook","mergeOptions","parent","child","options","key","mergeField","hasOwnProperty","Object","assign","oldArrayMethods","Array","prototype","arrayMethods","create","methods","method","ob","__ob__","args","result","apply","inserted","slice","observeArray","id","Dep","subs","target","addDep","addSub","watcher","push","update","pushTarget","popTarget","Observer","data","defineProperty","enumerable","configurable","value","isArray","__proto__","walk","i","length","observe","keys","defineReactive","dep","get","depend","set","newValue","notify","initState","vm","opts","$options","props","initData","proxy","property","_data","call","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","parseHTML","html","root","currentParent","stack","createASTElement","tagName","attrs","tag","children","type","start","element","end","pop","chars","text","replace","textEnd","indexOf","startTageMatch","parseStartTag","endTagMatch","match","advance","substring","n","attr","name","defaultTagRE","genProps","str","split","item","JSON","stringify","gen","node","generate","test","tokens","lastIndex","index","exec","trim","join","genChildren","el","map","c","code","undefined","compileToFunctions","template","ast","render","Function","has","queue","flushSchedulerQueue","run","queueWatcher","nextTick","callbacks","pending","flushCallbacksQueue","fn","setTimeout","Watcher","exprOrFn","cb","deps","depsId","Set","getter","add","patch","oldVnode","newVnode","isRealElement","nodeType","oldElm","parentElm","parentNode","createElm","insertBefore","nextSibling","removeChild","replaceChild","textContent","updateProperties","oldChildren","newChildren","updateChildren","innerHTML","appendChild","isSameVnode","oldStartIndex","oldStartVnode","oldEndIndex","oldEndVnode","newStartIndex","newStartVnode","newEndIndex","newEndVnode","makeIndexByKey","moveIndex","moveVnode","ele","vnode","document","createElement","createTextNode","oldProps","newProps","newStyle","style","oldStyle","removeAttribute","styleName","setAttribute","lifeCycleMixin","Vue","_update","$el","mountComponent","callHook","updateComponent","console","log","_render","handlers","initMixin","_init","constructor","$mount","querySelector","outerHTML","createTextVNode","renderMixin","_v","_c","arguments","_s","val","initGlobalAPI","mixin","$nextTick"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;EAGO,SAASA,QAAT,CAAkBC,GAAlB,EAAuB;EAC1B,SAAO,QAAOA,GAAP,MAAe,QAAf,IAA2BA,GAAG,KAAK,IAA1C;EACH;EACD,IAAMC,eAAe,GAAG,CACpB,cADoB,EAEpB,SAFoB,EAGpB,SAHoB,EAIpB,cAJoB,EAKpB,SALoB,CAAxB;EAOA,IAAIC,MAAM,GAAG,EAAb;;EACA,SAASC,SAAT,CAAmBC,SAAnB,EAA6BC,QAA7B,EAAsC;EAAE;EACpC,MAAGA,QAAH,EAAY;EAAE;EACV,QAAGD,SAAH,EAAa;EAAE;EACX,aAAOA,SAAS,CAACE,MAAV,CAAiBD,QAAjB,CAAP;EACH,KAFD,MAEK;EAAE;EACH,aAAO,CAACA,QAAD,CAAP,CADC;EAEJ;EACJ,GAND,MAMK;EACD,WAAOD,SAAP,CADC;EAEJ;EACJ;;EACDH,eAAe,CAACM,OAAhB,CAAwB,UAAAC,IAAI,EAAE;EAC1BN,EAAAA,MAAM,CAACM,IAAD,CAAN,GAAeL,SAAf;EACH,CAFD;EAGO,SAASM,YAAT,CAAsBC,MAAtB,EAA6BC,KAA7B,EAAmC;EAAE;EACxC,MAAMC,OAAO,GAAG,EAAhB,CADsC;;EAGtC,OAAI,IAAIC,GAAR,IAAeH,MAAf,EAAsB;EAAE;EACpBI,IAAAA,UAAU,CAACD,GAAD,CAAV;EACH;;EACD,OAAI,IAAIA,IAAR,IAAeF,KAAf,EAAqB;EAAE;EACnB,QAAG,CAACD,MAAM,CAACK,cAAP,CAAsBF,IAAtB,CAAJ,EAA+B;EAC3BC,MAAAA,UAAU,CAACD,IAAD,CAAV;EACH;EACJ;;EACD,WAASC,UAAT,CAAoBD,GAApB,EAAwB;EACpB;EAEA;EAEA;EACA,QAAGX,MAAM,CAACW,GAAD,CAAT,EAAe;EACX;EACAD,MAAAA,OAAO,CAACC,GAAD,CAAP,GAAeX,MAAM,CAACW,GAAD,CAAN,CAAYH,MAAM,CAACG,GAAD,CAAlB,EAAwBF,KAAK,CAACE,GAAD,CAA7B,CAAf;EACH,KAHD,MAGM,IAAGd,QAAQ,CAACW,MAAM,CAACG,GAAD,CAAP,CAAR,IAAyBd,QAAQ,CAACY,KAAK,CAACE,GAAD,CAAN,CAApC,EAAiD;EACnDD,MAAAA,OAAO,CAACC,GAAD,CAAP,GAAeG,MAAM,CAACC,MAAP,CAAcP,MAAM,CAACG,GAAD,CAApB,EAA0BF,KAAK,CAACE,GAAD,CAA/B,CAAf;EACH,KAFK,MAED;EACD,UAAGF,KAAK,CAACE,GAAD,CAAL,IAAc,IAAjB,EAAsB;EAClBD,QAAAA,OAAO,CAACC,GAAD,CAAP,GAAeH,MAAM,CAACG,GAAD,CAArB;EACH,OAFD,MAEK;EACDD,QAAAA,OAAO,CAACC,GAAD,CAAP,GAAeF,KAAK,CAACE,GAAD,CAApB,CADC;EAEJ;EACJ;EACJ,GA7BqC;;;EA8BtC,SAAOD,OAAP;EACH;;EC3DD,IAAIM,eAAe,GAAGC,KAAK,CAACC,SAA5B;EAEA;;EACO,IAAIC,YAAY,GAAGL,MAAM,CAACM,MAAP,CAAcJ,eAAd,CAAnB;EAEP,IAAIK,OAAO,GAAG;EACZ,MADY,EAEZ,KAFY,EAGZ,OAHY,EAIZ,SAJY,EAKZ,MALY,EAMZ,SANY,EAOZ,QAPY,CAAd;EASAA,OAAO,CAAChB,OAAR,CAAgB,UAAAiB,MAAM,EAAI;EACxBH,EAAAA,YAAY,CAACG,MAAD,CAAZ,GAAuB,YAAmB;EAAE;EAC1C;EACA,QAAMC,EAAE,GAAG,KAAKC,MAAhB;;EAFwC,sCAANC,IAAM;EAANA,MAAAA,IAAM;EAAA;;EAGxC,QAAIC,MAAM,GAAGV,eAAe,CAACM,MAAD,CAAf,CAAwBK,KAAxB,CAA8B,IAA9B,EAAoCF,IAApC,CAAb;EACA,QAAIG,QAAJ,CAJwC;EAMxC;;EACA,YAAQN,MAAR;EACE,WAAK,MAAL;EACA,WAAK,SAAL;EACEM,QAAAA,QAAQ,GAAGH,IAAX;EACA;;EACF,WAAK,QAAL;EAAe;EACbG,QAAAA,QAAQ,GAAGH,IAAI,CAACI,KAAL,CAAW,CAAX,CAAX;EACA;EAPJ;;EAWAD,IAAAA,QAAQ,IAAIL,EAAE,CAACO,YAAH,CAAgBF,QAAhB,CAAZ;EACA,WAAOF,MAAP;EACD,GApBD;EAqBD,CAtBD;;ECdA,IAAIK,EAAE,GAAG,CAAT;;MAEMC;EACJ,iBAAc;EAAA;;EACZ,SAAKD,EAAL,GAAUA,EAAE,EAAZ;EACA,SAAKE,IAAL,GAAY,EAAZ;EACD;;;;+BAEQ;EACP;EACA;EACAD,MAAAA,GAAG,CAACE,MAAJ,CAAWC,MAAX,CAAkB,IAAlB,EAHO;;EAIP,WAAKC,MAAL,CAAYJ,GAAG,CAACE,MAAhB;EACD;;;6BAEMG,SAAS;EACd,WAAKJ,IAAL,CAAUK,IAAV,CAAeD,OAAf;EACD;;;+BAEQ;EACP,WAAKJ,IAAL,CAAU5B,OAAV,CAAkB,UAAAgC,OAAO;EAAA,eAAIA,OAAO,CAACE,MAAR,EAAJ;EAAA,OAAzB;EACD;;;;;;EAGHP,GAAG,CAACE,MAAJ,GAAa,IAAb;EAGO,SAASM,UAAT,CAAoBH,OAApB,EAA6B;EAClCL,EAAAA,GAAG,CAACE,MAAJ,GAAaG,OAAb,CADkC;EAGnC;EAEM,SAASI,SAAT,GAAqB;EAC1BT,EAAAA,GAAG,CAACE,MAAJ,GAAa,IAAb,CAD0B;EAG1B;EACD;EAKD;;MCpCMQ;EACJ,oBAAYC,IAAZ,EAAkB;EAAA;;EAChB;EACA7B,IAAAA,MAAM,CAAC8B,cAAP,CAAsBD,IAAtB,EAA4B,QAA5B,EAAsC;EAAE;EACtCE,MAAAA,UAAU,EAAE,KADwB;EACjB;EACnBC,MAAAA,YAAY,EAAE,KAFsB;EAGpCC,MAAAA,KAAK,EAAE;EAH6B,KAAtC,EAFgB;;EAQhB,QAAI9B,KAAK,CAAC+B,OAAN,CAAcL,IAAd,CAAJ,EAAyB;EACvB;EACA;EACAA,MAAAA,IAAI,CAACM,SAAL,GAAiB9B,YAAjB,CAHuB;EAIvB;;EACA,WAAKW,YAAL,CAAkBa,IAAlB;EACD,KAND,MAMO;EACL,WAAKO,IAAL,CAAUP,IAAV,EADK;EAEN;EACF;;;;mCAEYA,MAAM;EACjB,WAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,IAAI,CAACS,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;EACpCE,QAAAA,OAAO,CAACV,IAAI,CAACQ,CAAD,CAAL,CAAP,CADoC;EAErC;EACF;;;2BAEIR,MAAM;EACT7B,MAAAA,MAAM,CAACwC,IAAP,CAAYX,IAAZ,EAAkBtC,OAAlB,CAA0B,UAAAM,GAAG,EAAI;EAC/B4C,QAAAA,cAAc,CAACZ,IAAD,EAAOhC,GAAP,EAAYgC,IAAI,CAAChC,GAAD,CAAhB,CAAd,CAD+B;EAEhC,OAFD;EAGD;;;;;EAIH;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EAEA;EACA;EACA;EACA;;;EAEA,SAAS4C,cAAT,CAAwBZ,IAAxB,EAA8BhC,GAA9B,EAAmCoC,KAAnC,EAA0C;EACxCM,EAAAA,OAAO,CAACN,KAAD,CAAP,CADwC;;EAExC,MAAIS,GAAG,GAAG,IAAIxB,GAAJ,EAAV,CAFwC;;EAGxClB,EAAAA,MAAM,CAAC8B,cAAP,CAAsBD,IAAtB,EAA4BhC,GAA5B,EAAiC;EAC/B8C,IAAAA,GAD+B,iBACzB;EACJ;EACA;EACA;EACA,UAAIzB,GAAG,CAACE,MAAR,EAAgB;EACdsB,QAAAA,GAAG,CAACE,MAAJ,GADc;EAEf;;EACD,aAAOX,KAAP;EACD,KAT8B;EAU/BY,IAAAA,GAV+B,eAU3BC,QAV2B,EAUjB;EACZ,UAAIA,QAAQ,IAAIb,KAAhB,EAAuB;EACvBM,MAAAA,OAAO,CAACO,QAAD,CAAP,CAFY;;EAGZb,MAAAA,KAAK,GAAGa,QAAR,CAHY;;EAMZJ,MAAAA,GAAG,CAACK,MAAJ;EACD;EAjB8B,GAAjC;EAmBD;;EAEM,SAASR,OAAT,CAAiBV,IAAjB,EAAuB;EAC5B;EACA;EACA,MAAI,CAAC9C,QAAQ,CAAC8C,IAAD,CAAb,EAAqB;EACnB;EACD;;EACD,MAAIA,IAAI,CAACnB,MAAL,YAAuBkB,QAA3B,EAAqC;EAAE;EACrC;EACD,GAR2B;;;EAW5B,SAAO,IAAIA,QAAJ,CAAaC,IAAb,CAAP,CAX4B;EAY7B;;ECzFM,SAASmB,SAAT,CAAmBC,EAAnB,EAAuB;EAC5B,MAAMC,IAAI,GAAGD,EAAE,CAACE,QAAhB;;EACA,MAAID,IAAI,CAACE,KAAT,EAAgB;;EAGhB,MAAIF,IAAI,CAAC3C,OAAT,EAAkB;;EAGlB,MAAI2C,IAAI,CAACrB,IAAT,EAAe;EACbwB,IAAAA,QAAQ,CAACJ,EAAD,CAAR;EACD,GAV2B;;EAY7B;;EAQD,SAASK,KAAT,CAAelC,MAAf,EAAuBmC,QAAvB,EAAiC1D,GAAjC,EAAsC;EACpCG,EAAAA,MAAM,CAAC8B,cAAP,CAAsBV,MAAtB,EAA8BvB,GAA9B,EAAmC;EACjC8C,IAAAA,GADiC,iBAC3B;EACJ,aAAOvB,MAAM,CAACmC,QAAD,CAAN,CAAiB1D,GAAjB,CAAP;EACD,KAHgC;EAIjCgD,IAAAA,GAJiC,eAI7BC,QAJ6B,EAInB;EACZ1B,MAAAA,MAAM,CAACmC,QAAD,CAAN,CAAiB1D,GAAjB,IAAwBiD,QAAxB;EACD;EANgC,GAAnC;EAQD;;EAED,SAASO,QAAT,CAAkBJ,EAAlB,EAAsB;EACpB;EACA,MAAIpB,IAAI,GAAGoB,EAAE,CAACE,QAAH,CAAYtB,IAAvB,CAFoB;EAGpB;;EACAA,EAAAA,IAAI,GAAGoB,EAAE,CAACO,KAAH,GAAW,OAAO3B,IAAP,KAAgB,UAAhB,GAA6BA,IAAI,CAAC4B,IAAL,CAAUR,EAAV,CAA7B,GAA6CpB,IAA/D,CAJoB;EAMpB;EAEA;EACA;;EACA,OAAK,IAAIhC,GAAT,IAAgBgC,IAAhB,EAAsB;EACpByB,IAAAA,KAAK,CAACL,EAAD,EAAK,OAAL,EAAcpD,GAAd,CAAL;EACD;;EACD0C,EAAAA,OAAO,CAACV,IAAD,CAAP,CAboB;EAcrB;;EC/CD;EACA,IAAM6B,MAAM,iCAAZ;EACA;;EACA,IAAMC,YAAY,iBAAUD,MAAV,kBAAwBA,MAAxB,MAAlB;;EAEA,IAAME,YAAY,GAAG,IAAIC,MAAJ,aAAgBF,YAAhB,EAArB;EACA;;EACA,IAAMG,MAAM,GAAG,IAAID,MAAJ,gBAAmBF,YAAnB,YAAf;EACA;EACA;;EACA,IAAMI,SAAS,GAAG,2EAAlB;EACA;;EACA,IAAMC,aAAa,GAAG,YAAtB;EAIO,SAASC,SAAT,CAAmBC,IAAnB,EAAyB;EAC9B;EACA,MAAIC,IAAJ,CAF8B;;EAG9B,MAAIC,aAAJ;EACA,MAAIC,KAAK,GAAG,EAAZ,CAJ8B;EAK9B;EAEA;EAEA;;EACA,WAASC,gBAAT,CAA0BC,OAA1B,EAAmCC,KAAnC,EAA0C;EACxC,WAAO;EACLC,MAAAA,GAAG,EAAEF,OADA;EAELC,MAAAA,KAAK,EAALA,KAFK;EAGLE,MAAAA,QAAQ,EAAE,EAHL;EAILhF,MAAAA,MAAM,EAAE,IAJH;EAKLiF,MAAAA,IAAI,EAAE,CALD;;EAAA,KAAP;EAOD,GAlB6B;;;EAqB9B,WAASC,KAAT,CAAeL,OAAf,EAAwBC,KAAxB,EAA+B;EAAE;EAC/B,QAAIK,OAAO,GAAGP,gBAAgB,CAACC,OAAD,EAAUC,KAAV,CAA9B;;EACA,QAAI,CAACL,IAAL,EAAW;EACTA,MAAAA,IAAI,GAAGU,OAAP,CADS;EAEV;;EACDT,IAAAA,aAAa,GAAGS,OAAhB;EACAR,IAAAA,KAAK,CAAC7C,IAAN,CAAWqD,OAAX;EACD,GA5B6B;;;EA+B9B,WAASC,GAAT,CAAaP,OAAb,EAAsB;EAAE;EACtB,QAAIM,OAAO,GAAGR,KAAK,CAACU,GAAN,EAAd;EACAX,IAAAA,aAAa,GAAGC,KAAK,CAACA,KAAK,CAAC/B,MAAN,GAAe,CAAhB,CAArB;;EACA,QAAI8B,aAAJ,EAAmB;EACjBS,MAAAA,OAAO,CAACnF,MAAR,GAAiB0E,aAAjB;EACAA,MAAAA,aAAa,CAACM,QAAd,CAAuBlD,IAAvB,CAA4BqD,OAA5B;EACD;EACF;;EAED,WAASG,KAAT,CAAeC,IAAf,EAAqB;EAAE;EACrBA,IAAAA,IAAI,GAAGA,IAAI,CAACC,OAAL,CAAa,KAAb,EAAoB,EAApB,CAAP;;EACA,QAAID,IAAJ,EAAU;EACRb,MAAAA,aAAa,CAACM,QAAd,CAAuBlD,IAAvB,CAA4B;EAC1BmD,QAAAA,IAAI,EAAE,CADoB;EAE1BM,QAAAA,IAAI,EAAJA;EAF0B,OAA5B;EAID;EACF,GAhD6B;;;EAmD9B,SAAOf,IAAP,EAAa;EACX,QAAIiB,OAAO,GAAGjB,IAAI,CAACkB,OAAL,CAAa,GAAb,CAAd;;EACA,QAAID,OAAO,IAAI,CAAf,EAAkB;EAChB,UAAME,cAAc,GAAGC,aAAa,EAApC;;EAEA,UAAID,cAAJ,EAAoB;EAClB;EACAT,QAAAA,KAAK,CAACS,cAAc,CAACd,OAAhB,EAAyBc,cAAc,CAACb,KAAxC,CAAL;EACD;;EACD,UAAMe,WAAW,GAAGrB,IAAI,CAACsB,KAAL,CAAW1B,MAAX,CAApB;;EAEA,UAAIyB,WAAJ,EAAiB;EACfE,QAAAA,OAAO,CAACF,WAAW,CAAC,CAAD,CAAX,CAAejD,MAAhB,CAAP;EACAwC,QAAAA,GAAG,CAACS,WAAW,CAAC,CAAD,CAAZ,CAAH;EACD,OAZe;;EAcjB,KAhBU;;;EAmBX,QAAIN,IAAI,SAAR;;EACA,QAAIE,OAAO,GAAG,CAAd,EAAiB;EACfF,MAAAA,IAAI,GAAGf,IAAI,CAACwB,SAAL,CAAe,CAAf,EAAkBP,OAAlB,CAAP,CADe;;EAEfH,MAAAA,KAAK,CAACC,IAAD,CAAL;EACD;;EACD,QAAIA,IAAJ,EAAU;EACRQ,MAAAA,OAAO,CAACR,IAAI,CAAC3C,MAAN,CAAP,CADQ;EAET;EACF;;EAED,WAASmD,OAAT,CAAiBE,CAAjB,EAAoB;EAClBzB,IAAAA,IAAI,GAAGA,IAAI,CAACwB,SAAL,CAAeC,CAAf,CAAP;EACD;;EAED,WAASL,aAAT,GAAyB;EACvB,QAAMV,KAAK,GAAGV,IAAI,CAACsB,KAAL,CAAW5B,YAAX,CAAd,CADuB;;EAEvB,QAAIgB,KAAJ,EAAW;EACT,UAAMY,KAAK,GAAG;EACZjB,QAAAA,OAAO,EAAEK,KAAK,CAAC,CAAD,CADF;EACO;EACnBJ,QAAAA,KAAK,EAAE;EAFK,OAAd;EAIAiB,MAAAA,OAAO,CAACb,KAAK,CAAC,CAAD,CAAL,CAAStC,MAAV,CAAP;;EACA,UAAIwC,IAAJ,EAASc,IAAT;;EACA,aAAO,EAAEd,IAAG,GAAGZ,IAAI,CAACsB,KAAL,CAAWxB,aAAX,CAAR,MAAuC4B,IAAI,GAAG1B,IAAI,CAACsB,KAAL,CAAWzB,SAAX,CAA9C,CAAP,EAA6E;EAC3E0B,QAAAA,OAAO,CAACG,IAAI,CAAC,CAAD,CAAJ,CAAQtD,MAAT,CAAP;EACAkD,QAAAA,KAAK,CAAChB,KAAN,CAAYhD,IAAZ,CAAiB;EAACqE,UAAAA,IAAI,EAAED,IAAI,CAAC,CAAD,CAAX;EAAgB3D,UAAAA,KAAK,EAAE2D,IAAI,CAAC,CAAD,CAAJ,IAAWA,IAAI,CAAC,CAAD,CAAf,IAAsBA,IAAI,CAAC,CAAD;EAAjD,SAAjB;EACD;;EAED,UAAId,IAAJ,EAAS;EACPW,QAAAA,OAAO,CAACX,IAAG,CAAC,CAAD,CAAH,CAAOxC,MAAR,CAAP;EACA,eAAOkD,KAAP;EACD;EACF;EACF;;EAED,SAAOrB,IAAP;EAED;;EC3HD,IAAM2B,YAAY,GAAG,0BAArB;;EAEA,SAASC,QAAT,CAAkBvB,KAAlB,EAAyB;EAAG;EAC1B,MAAIwB,GAAG,GAAG,EAAV;;EACA,OAAK,IAAI3D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmC,KAAK,CAAClC,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;EACrC,QAAIuD,IAAI,GAAGpB,KAAK,CAACnC,CAAD,CAAhB,CADqC;;EAErC,QAAIuD,IAAI,CAACC,IAAL,KAAc,OAAlB,EAA2B;EAAA;EACzB,YAAI7G,GAAG,GAAG,EAAV,CADyB;;EAEzB4G,QAAAA,IAAI,CAAC3D,KAAL,CAAWgE,KAAX,CAAiB,GAAjB,EAAsB1G,OAAtB,CAA8B,UAAA2G,IAAI,EAAI;EAAA,4BACjBA,IAAI,CAACD,KAAL,CAAW,GAAX,CADiB;EAAA;EAAA,cAC/BpG,GAD+B;EAAA,cAC1BoC,KAD0B;;EAEpCjD,UAAAA,GAAG,CAACa,GAAD,CAAH,GAAWoC,KAAX;EACD,SAHD;EAIA2D,QAAAA,IAAI,CAAC3D,KAAL,GAAajD,GAAb,CANyB;EAAA;EAO1B;;EACDgH,IAAAA,GAAG,cAAOJ,IAAI,CAACC,IAAZ,cAAoBM,IAAI,CAACC,SAAL,CAAeR,IAAI,CAAC3D,KAApB,CAApB,MAAH;EACD;;EACD,oBAAW+D,GAAG,CAACjF,KAAJ,CAAU,CAAV,EAAa,CAAC,CAAd,CAAX;EACD;;EAED,SAASsF,GAAT,CAAaC,IAAb,EAAmB;EACjB,MAAIA,IAAI,CAAC3B,IAAL,KAAc,CAAlB,EAAqB;EACnB,WAAO4B,QAAQ,CAACD,IAAD,CAAf;EACD,GAFD,MAEO;EACL;EACA,QAAIrB,IAAI,GAAGqB,IAAI,CAACrB,IAAhB;;EACA,QAAI,CAACa,YAAY,CAACU,IAAb,CAAkBvB,IAAlB,CAAL,EAA8B;EAAG;EAC/B,0BAAakB,IAAI,CAACC,SAAL,CAAenB,IAAf,CAAb,OAD4B;EAE7B,KAFD,MAEO;EACL,UAAIwB,MAAM,GAAG,EAAb,CADK;;EAEL,UAAIC,SAAS,GAAGZ,YAAY,CAACY,SAAb,GAAyB,CAAzC;EACA,UAAIlB,KAAJ,EAAWmB,KAAX;;EACA,aAAOnB,KAAK,GAAGM,YAAY,CAACc,IAAb,CAAkB3B,IAAlB,CAAf,EAAwC;EACtC0B,QAAAA,KAAK,GAAGnB,KAAK,CAACmB,KAAd,CADsC;;EAGtCF,QAAAA,MAAM,CAACjF,IAAP,CAAY2E,IAAI,CAACC,SAAL,CAAenB,IAAI,CAAClE,KAAL,CAAW2F,SAAX,EAAsBC,KAAtB,CAAf,CAAZ;EACAF,QAAAA,MAAM,CAACjF,IAAP,cAAkBgE,KAAK,CAAC,CAAD,CAAL,CAASqB,IAAT,EAAlB;EACAH,QAAAA,SAAS,GAAGC,KAAK,GAAGnB,KAAK,CAAC,CAAD,CAAL,CAASlD,MAA7B;EACD;;EACD,UAAIoE,SAAS,GAAGzB,IAAI,CAAC3C,MAArB,EAA6B;EAC3BmE,QAAAA,MAAM,CAACjF,IAAP,CAAY2E,IAAI,CAACC,SAAL,CAAenB,IAAI,CAAClE,KAAL,CAAW2F,SAAX,CAAf,CAAZ;EACD;;EACD,0BAAaD,MAAM,CAACK,IAAP,CAAY,GAAZ,CAAb;EACD,KApBI;;EAsBN;EACF;;EAED,SAASC,WAAT,CAAqBC,EAArB,EAAyB;EAAE;EACzB,MAAMtC,QAAQ,GAAGsC,EAAE,CAACtC,QAApB;;EACA,MAAIA,QAAJ,EAAc;EACZ,WAAOA,QAAQ,CAACuC,GAAT,CAAa,UAAAC,CAAC;EAAA,aAAIb,GAAG,CAACa,CAAD,CAAP;EAAA,KAAd,EAA0BJ,IAA1B,CAA+B,GAA/B,CAAP;EACD,GAFD,MAEO;EACL,WAAO,KAAP;EACD;EACF;;EAEM,SAASP,QAAT,CAAkBS,EAAlB,EAAsB;EAC3B,MAAItC,QAAQ,GAAGqC,WAAW,CAACC,EAAD,CAA1B,CAD2B;;EAE3B,MAAIG,IAAI,kBAAUH,EAAE,CAACvC,GAAb,gBACNuC,EAAE,CAACxC,KAAH,CAASlC,MAAT,aAAqByD,QAAQ,CAACiB,EAAE,CAACxC,KAAJ,CAA7B,IAA4C4C,SADtC,SAGN1C,QAAQ,cAAOA,QAAP,IAAoB,EAHtB,MAAR;EAMA,SAAOyC,IAAP;EACD;;EC/DM,SAASE,kBAAT,CAA4BC,QAA5B,EAAqC;EACxC;EACA;EACA,MAAIC,GAAG,GAAGtD,SAAS,CAACqD,QAAD,CAAnB,CAHwC;EAOxC;EACA;;EAEA;;;;;;;;;EASA;;EACA,MAAIH,IAAI,GAAGZ,QAAQ,CAACgB,GAAD,CAAnB,CApBwC;;EAsBxCJ,EAAAA,IAAI,oCAA6BA,IAA7B,WAAJ;EAEA,MAAIK,MAAM,GAAG,IAAIC,QAAJ,CAAaN,IAAb,CAAb,CAxBwC;EA2BxC;;EAEA,SAAOK,MAAP,CA7BwC;EA+BxC;EACA;EACA;EACA;EACH;;ECrCD,IAAIE,GAAG,GAAG,EAAV;;EACA,IAAIC,KAAK,GAAG,EAAZ;;EAGA,SAASC,mBAAT,GAA+B;EAC7B,OAAK,IAAIvF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsF,KAAK,CAACrF,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;EACrCsF,IAAAA,KAAK,CAACtF,CAAD,CAAL,CAASwF,GAAT;EACD;;EACDF,EAAAA,KAAK,GAAG,EAAR;EACAD,EAAAA,GAAG,GAAG,EAAN;EACD;;EAGM,SAASI,YAAT,CAAsBvG,OAAtB,EAA+B;EACpC,MAAMN,EAAE,GAAGM,OAAO,CAACN,EAAnB;;EAEA,MAAIyG,GAAG,CAACzG,EAAD,CAAH,IAAW,IAAf,EAAqB;EACnByG,IAAAA,GAAG,CAACzG,EAAD,CAAH,GAAU,IAAV,CADmB;;EAEnB0G,IAAAA,KAAK,CAACnG,IAAN,CAAWD,OAAX;EACAwG,IAAAA,QAAQ,CAACH,mBAAD,CAAR,CAHmB;EAIpB;EACF;EAED,IAAII,SAAS,GAAG,EAAhB;;EACA,IAAIC,OAAO,GAAG,KAAd;;EAEA,SAASC,mBAAT,GAA+B;EAC7BF,EAAAA,SAAS,CAACzI,OAAV,CAAkB,UAAA4I,EAAE;EAAA,WAAIA,EAAE,EAAN;EAAA,GAApB;EACAF,EAAAA,OAAO,GAAG,KAAV;EACD;;EAEM,SAASF,QAAT,CAAkBI,EAAlB,EAAsB;EAC3BH,EAAAA,SAAS,CAACxG,IAAV,CAAe2G,EAAf,EAD2B;;EAE3B,MAAI,CAACF,OAAL,EAAc;EAAE;EACdG,IAAAA,UAAU,CAAC,YAAM;EACfF,MAAAA,mBAAmB;EACpB,KAFS,EAEP,CAFO,CAAV;EAGAD,IAAAA,OAAO,GAAG,IAAV;EACD;EACF;;ECpCD,IAAIhH,IAAE,GAAG,CAAT;EACA;;MAEMoH;EACJ;EACA;EACA,mBAAYpF,EAAZ,EAAgBqF,QAAhB,EAA0BC,EAA1B,EAA8B3I,OAA9B,EAAuC;EAAA;;EACrC,SAAKqD,EAAL,GAAUA,EAAV;EACA,SAAKqF,QAAL,GAAgBA,QAAhB,CAFqC;;EAGrC,SAAKC,EAAL,GAAUA,EAAV;EACA,SAAK3I,OAAL,GAAeA,OAAf;EACA,SAAK4I,IAAL,GAAY,EAAZ,CALqC;;EAMrC,SAAKC,MAAL,GAAc,IAAIC,GAAJ,EAAd;;EACA,QAAI,OAAOJ,QAAP,IAAmB,UAAvB,EAAmC;EACjC,WAAKK,MAAL,GAAcL,QAAd,CADiC;EAElC;;EACD,SAAKrH,EAAL,GAAUA,IAAE,EAAZ;EACA,SAAK0B,GAAL;EACD;;;;4BAEK;EACJ,WAAKA,GAAL,GADI;EAEL;;;4BAEK;EACJ;EACA;EACA;EACA;EAGA;EACAjB,MAAAA,UAAU,CAAC,IAAD,CAAV,CARI;;EASJ,WAAKiH,MAAL,GATI;;EAUJhH,MAAAA,SAAS,GAVL;EAWJ;EACD;;;6BAEMe,KAAK;EACV,UAAIzB,EAAE,GAAGyB,GAAG,CAACzB,EAAb;;EACA,UAAI,CAAC,KAAKwH,MAAL,CAAYf,GAAZ,CAAgBzG,EAAhB,CAAL,EAA0B;EACxB,aAAKwH,MAAL,CAAYG,GAAZ,CAAgB3H,EAAhB;EACA,aAAKuH,IAAL,CAAUhH,IAAV,CAAekB,GAAf;EACAA,QAAAA,GAAG,CAACpB,MAAJ,CAAW,IAAX,EAHwB;EAIzB;EACF;;;+BAEQ;EAAE;EACTwG,MAAAA,YAAY,CAAC,IAAD,CAAZ,CADO;EAEP;EACD;;;;;;ECrDI,SAASe,KAAT,CAAeC,QAAf,EAAyBC,QAAzB,EAAmC;EACxC,MAAMC,aAAa,GAAGF,QAAQ,CAACG,QAA/B;;EACA,MAAID,aAAJ,EAAmB;EACjB;EACA,QAAME,MAAM,GAAGJ,QAAf;EACA,QAAMK,SAAS,GAAGD,MAAM,CAACE,UAAzB;EACA,QAAIpC,EAAE,GAAGqC,SAAS,CAACN,QAAD,CAAlB;EACAI,IAAAA,SAAS,CAACG,YAAV,CAAuBtC,EAAvB,EAA2BkC,MAAM,CAACK,WAAlC;EACAJ,IAAAA,SAAS,CAACK,WAAV,CAAsBN,MAAtB;EACA,WAAOlC,EAAP,CAPiB;EAQlB,GARD,MAQO;EACL;EACA;EAEA;EAEA,QAAI8B,QAAQ,CAACrE,GAAT,KAAiBsE,QAAQ,CAACtE,GAA9B,EAAmC;EAAE;EACnCqE,MAAAA,QAAQ,CAAC9B,EAAT,CAAYoC,UAAZ,CAAuBK,YAAvB,CAAoCJ,SAAS,CAACN,QAAD,CAA7C,EAAyDD,QAAQ,CAAC9B,EAAlE;EACD,KARI;;;EAWL,QAAI,CAAC8B,QAAQ,CAACrE,GAAd,EAAmB;EAAE;EACnB,UAAIqE,QAAQ,CAAC7D,IAAT,KAAkB8D,QAAQ,CAAC9D,IAA/B,EAAqC;EACnC6D,QAAAA,QAAQ,CAAC9B,EAAT,CAAY0C,WAAZ,GAA0BX,QAAQ,CAAC9D,IAAnC;EACD;EACF,KAfI;EAiBL;;;EACA,QAAI+B,GAAE,GAAG+B,QAAQ,CAAC/B,EAAT,GAAc8B,QAAQ,CAAC9B,EAAhC,CAlBK;;;EAoBL2C,IAAAA,gBAAgB,CAACZ,QAAD,EAAWD,QAAQ,CAACjH,IAApB,CAAhB,CApBK;EAsBL;;EACA,QAAI+H,WAAW,GAAGd,QAAQ,CAACpE,QAAT,IAAqB,EAAvC,CAvBK;;EAwBL,QAAImF,WAAW,GAAGd,QAAQ,CAACrE,QAAT,IAAqB,EAAvC,CAxBK;EA0BL;EACA;EACA;;EAEA,QAAIkF,WAAW,CAACtH,MAAZ,GAAqB,CAArB,IAA0BuH,WAAW,CAACvH,MAAZ,GAAqB,CAAnD,EAAsD;EACpD;EACAwH,MAAAA,cAAc,CAAC9C,GAAD,EAAK4C,WAAL,EAAkBC,WAAlB,CAAd,CAFoD;EAKrD,KALD,MAKO,IAAID,WAAW,CAACtH,MAAZ,GAAqB,CAAzB,EAA4B;EACjC0E,MAAAA,GAAE,CAAC+C,SAAH,GAAe,EAAf;EACD,KAFM,MAEA,IAAIF,WAAW,CAACvH,MAAZ,GAAqB,CAAzB,EAA4B;EACjC,WAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwH,WAAW,CAACvH,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;EAC3C,YAAI1C,KAAK,GAAGkK,WAAW,CAACxH,CAAD,CAAvB,CAD2C;;EAE3C2E,QAAAA,GAAE,CAACgD,WAAH,CAAeX,SAAS,CAAC1J,KAAD,CAAxB,EAF2C;;EAG5C;EACF;;EACD,WAAOqH,GAAP;EACD;EACF;;EAED,SAASiD,WAAT,CAAqBnB,QAArB,EAA+BC,QAA/B,EAAyC;EACvC,SAAQD,QAAQ,CAACjJ,GAAT,IAAgBkJ,QAAQ,CAAClJ,GAA1B,IAAmCiJ,QAAQ,CAACrE,GAAT,KAAiBsE,QAAQ,CAACtE,GAApE;EACD;;EAED,SAASqF,cAAT,CAAwBpK,MAAxB,EAAgCkK,WAAhC,EAA6CC,WAA7C,EAA0D;EACxD;EACA;EAEA,MAAIK,aAAa,GAAG,CAApB,CAJwD;;EAKxD,MAAIC,aAAa,GAAGP,WAAW,CAAC,CAAD,CAA/B,CALwD;;EAMxD,MAAIQ,WAAW,GAAGR,WAAW,CAACtH,MAAZ,GAAqB,CAAvC,CANwD;;EAOxD,MAAI+H,WAAW,GAAGT,WAAW,CAACQ,WAAD,CAA7B,CAPwD;;EASxD,MAAIE,aAAa,GAAG,CAApB,CATwD;;EAUxD,MAAIC,aAAa,GAAGV,WAAW,CAAC,CAAD,CAA/B,CAVwD;;EAWxD,MAAIW,WAAW,GAAGX,WAAW,CAACvH,MAAZ,GAAqB,CAAvC,CAXwD;;EAYxD,MAAImI,WAAW,GAAGZ,WAAW,CAACW,WAAD,CAA7B,CAZwD;;EAcxD,WAASE,cAAT,CAAwBhG,QAAxB,EAAkC;EAAE;EAClC,QAAIuC,GAAG,GAAG,EAAV;EACAvC,IAAAA,QAAQ,CAACnF,OAAT,CAAiB,UAAC2G,IAAD,EAAOS,KAAP,EAAiB;EAChCM,MAAAA,GAAG,CAACf,IAAI,CAACrG,GAAN,CAAH,GAAgB8G,KAAhB;EACD,KAFD;EAGA,WAAOM,GAAP;EACD;;EAED,MAAIA,GAAG,GAAGyD,cAAc,CAACd,WAAD,CAAxB,CAtBwD;EAuBxD;EACA;;EACA,SAAOM,aAAa,IAAIE,WAAjB,IAAgCE,aAAa,IAAIE,WAAxD,EAAqE;EACnE;EACA,QAAI,CAACL,aAAL,EAAoB;EAClBA,MAAAA,aAAa,GAAGP,WAAW,CAAC,EAAEM,aAAH,CAA3B;EACD,KAFD,MAEO,IAAI,CAACG,WAAL,EAAkB;EACvBA,MAAAA,WAAW,GAAGT,WAAW,CAAC,EAAEQ,WAAH,CAAzB;EACD,KAFM,MAEA,IAAIH,WAAW,CAACE,aAAD,EAAgBI,aAAhB,CAAf,EAA+C;EACpD;EACA1B,MAAAA,KAAK,CAACsB,aAAD,EAAgBI,aAAhB,CAAL,CAFoD;;EAGpDJ,MAAAA,aAAa,GAAGP,WAAW,CAAC,EAAEM,aAAH,CAA3B;EACAK,MAAAA,aAAa,GAAGV,WAAW,CAAC,EAAES,aAAH,CAA3B,CAJoD;EAMrD,KANM,MAMA,IAAIL,WAAW,CAACI,WAAD,EAAcI,WAAd,CAAf,EAA2C;EAChD;EACA5B,MAAAA,KAAK,CAACwB,WAAD,EAAcI,WAAd,CAAL;EACAJ,MAAAA,WAAW,GAAGT,WAAW,CAAC,EAAEQ,WAAH,CAAzB,CAHgD;;EAIhDK,MAAAA,WAAW,GAAGZ,WAAW,CAAC,EAAEW,WAAH,CAAzB;EACD,KALM,MAKA,IAAIP,WAAW,CAACE,aAAD,EAAgBM,WAAhB,CAAf,EAA6C;EAAE;EACpD;EACA5B,MAAAA,KAAK,CAACsB,aAAD,EAAgBM,WAAhB,CAAL;EACA/K,MAAAA,MAAM,CAAC4J,YAAP,CAAoBa,aAAa,CAACnD,EAAlC,EAAsCqD,WAAW,CAACrD,EAAZ,CAAeuC,WAArD,EAHkD;;EAIlDY,MAAAA,aAAa,GAAGP,WAAW,CAAC,EAAEM,aAAH,CAA3B;EACAO,MAAAA,WAAW,GAAGZ,WAAW,CAAC,EAAEW,WAAH,CAAzB;EACD,KANM,MAMA,IAAIP,WAAW,CAACI,WAAD,EAAcE,aAAd,CAAf,EAA6C;EAAE;EACpD1B,MAAAA,KAAK,CAACwB,WAAD,EAAcE,aAAd,CAAL;EACA7K,MAAAA,MAAM,CAAC4J,YAAP,CAAoBe,WAAW,CAACrD,EAAhC,EAAoCmD,aAAa,CAACnD,EAAlD;EACAqD,MAAAA,WAAW,GAAGT,WAAW,CAAC,EAAEQ,WAAH,CAAzB;EACAG,MAAAA,aAAa,GAAGV,WAAW,CAAC,EAAES,aAAH,CAA3B;EACD,KALM,MAKA;EACL;EACA,UAAIK,SAAS,GAAG1D,GAAG,CAACsD,aAAa,CAAC1K,GAAf,CAAnB;;EACA,UAAI8K,SAAS,IAAIvD,SAAjB,EAA4B;EAAE;EAC5B1H,QAAAA,MAAM,CAAC4J,YAAP,CAAoBD,SAAS,CAACkB,aAAD,CAA7B,EAA8CJ,aAAa,CAACnD,EAA5D;EACD,OAFD,MAEO;EACL,YAAI4D,SAAS,GAAGhB,WAAW,CAACe,SAAD,CAA3B;EACAf,QAAAA,WAAW,CAACe,SAAD,CAAX,GAAyB,IAAzB,CAFK;EAIL;;EACA9B,QAAAA,KAAK,CAAC+B,SAAD,EAAYL,aAAZ,CAAL;EACA7K,QAAAA,MAAM,CAAC4J,YAAP,CAAoBsB,SAAS,CAAC5D,EAA9B,EAAkCmD,aAAa,CAACnD,EAAhD;EACD;;EACDuD,MAAAA,aAAa,GAAGV,WAAW,CAAC,EAAES,aAAH,CAA3B,CAbK;EAcN;EAEF;;EACD,MAAIA,aAAa,IAAIE,WAArB,EAAkC;EAChC,SAAK,IAAInI,CAAC,GAAGiI,aAAb,EAA4BjI,CAAC,IAAImI,WAAjC,EAA8CnI,CAAC,EAA/C,EAAmD;EACjD;EACA,UAAIwI,GAAG,GAAGhB,WAAW,CAACW,WAAW,GAAG,CAAf,CAAX,IAAgC,IAAhC,GAAuC,IAAvC,GAA8CX,WAAW,CAACW,WAAW,GAAG,CAAf,CAAX,CAA6BxD,EAArF;EACAtH,MAAAA,MAAM,CAAC4J,YAAP,CAAoBD,SAAS,CAACQ,WAAW,CAACxH,CAAD,CAAZ,CAA7B,EAA+CwI,GAA/C,EAHiD;EAKlD;EACF;;EACD,MAAIX,aAAa,IAAIE,WAArB,EAAkC;EAAE;EAClC,SAAK,IAAI/H,EAAC,GAAG6H,aAAb,EAA4B7H,EAAC,IAAI+H,WAAjC,EAA8C/H,EAAC,EAA/C,EAAmD;EACjD,UAAI1C,KAAK,GAAGiK,WAAW,CAACvH,EAAD,CAAvB;;EACA,UAAI1C,KAAK,IAAI,IAAb,EAAmB;EACjBD,QAAAA,MAAM,CAAC8J,WAAP,CAAmB7J,KAAK,CAACqH,EAAzB;EACD;EACF;EACF,GArFuD;EAwFxD;;EAGD;;EAEM,SAASqC,SAAT,CAAmByB,KAAnB,EAA0B;EAAE;EAAF,MAC1BrG,GAD0B,GACQqG,KADR,CAC1BrG,GAD0B;EAAA,MACrBC,QADqB,GACQoG,KADR,CACrBpG,QADqB;EAAA,MACX7C,IADW,GACQiJ,KADR,CACXjJ,IADW;EAAA,MACLhC,GADK,GACQiL,KADR,CACLjL,GADK;EAAA,MACAoF,IADA,GACQ6F,KADR,CACA7F,IADA;;EAE/B,MAAI,OAAOR,GAAP,IAAc,QAAlB,EAA4B;EAC1B;EACAqG,IAAAA,KAAK,CAAC9D,EAAN,GAAW+D,QAAQ,CAACC,aAAT,CAAuBvG,GAAvB,CAAX;EACAkF,IAAAA,gBAAgB,CAACmB,KAAD,CAAhB,CAH0B;;EAI1BpG,IAAAA,QAAQ,CAACnF,OAAT,CAAiB,UAAAI,KAAK,EAAI;EACxB;EACAmL,MAAAA,KAAK,CAAC9D,EAAN,CAASgD,WAAT,CAAqBX,SAAS,CAAC1J,KAAD,CAA9B;EACD,KAHD;EAID,GARD,MAQO;EACL;EACAmL,IAAAA,KAAK,CAAC9D,EAAN,GAAW+D,QAAQ,CAACE,cAAT,CAAwBhG,IAAxB,CAAX;EACD;;EACD,SAAO6F,KAAK,CAAC9D,EAAb;EACD;;EAED,SAAS2C,gBAAT,CAA0BmB,KAA1B,EAAgD;EAAA,MAAfI,QAAe,uEAAJ,EAAI;EAE9C;EAEA,MAAIlE,EAAE,GAAG8D,KAAK,CAAC9D,EAAf;EACA,MAAImE,QAAQ,GAAGL,KAAK,CAACjJ,IAAN,IAAc,EAA7B,CAL8C;;EAO9C,MAAIuJ,QAAQ,GAAGD,QAAQ,CAACE,KAAT,IAAkB,EAAjC;EACA,MAAIC,QAAQ,GAAGJ,QAAQ,CAACG,KAAT,IAAkB,EAAjC;;EAEA,OAAK,IAAIxL,GAAT,IAAgByL,QAAhB,EAA0B;EACxB,QAAI,CAACF,QAAQ,CAACvL,GAAD,CAAb,EAAoB;EAClBmH,MAAAA,EAAE,CAACqE,KAAH,CAASxL,GAAT,IAAgB,EAAhB,CADkB;EAEnB;EACF;;EACD,OAAK,IAAIA,IAAT,IAAgBqL,QAAhB,EAA0B;EACxB,QAAI,CAACC,QAAQ,CAACtL,IAAD,CAAb,EAAoB;EAAE;EACpBmH,MAAAA,EAAE,CAACuE,eAAH,CAAmB1L,IAAnB;EACD;EACF,GAnB6C;;;EAsB9C,OAAK,IAAIA,KAAT,IAAgBsL,QAAhB,EAA0B;EACxB,QAAItL,KAAG,IAAI,OAAX,EAAoB;EAClB,WAAK,IAAI2L,SAAT,IAAsBL,QAAQ,CAACE,KAA/B,EAAsC;EAAE;EACtCrE,QAAAA,EAAE,CAACqE,KAAH,CAASG,SAAT,IAAsBL,QAAQ,CAACE,KAAT,CAAeG,SAAf,CAAtB;EACD,OAHiB;;EAKnB,KALD;EAAA,SAOK;EACHxE,QAAAA,EAAE,CAACyE,YAAH,CAAgB5L,KAAhB,EAAqBsL,QAAQ,CAACtL,KAAD,CAA7B;EACD;EACF;EACF;;EC1MM,SAAS6L,cAAT,CAAwBC,GAAxB,EAA6B;EAClCA,EAAAA,GAAG,CAACvL,SAAJ,CAAcwL,OAAd,GAAwB,UAAUd,KAAV,EAAiB;EACvC,QAAM7H,EAAE,GAAG,IAAX,CADuC;EAGvC;;EACAA,IAAAA,EAAE,CAAC4I,GAAH,GAAShD,KAAK,CAAC5F,EAAE,CAAC4I,GAAJ,EAASf,KAAT,CAAd;EAED,GAND;EAOD;EAEM,SAASgB,cAAT,CAAwB7I,EAAxB,EAA4B+D,EAA5B,EAAgC;EACrC;EACA;EACA;EACA+E,EAAAA,QAAQ,CAAC9I,EAAD,EAAK,aAAL,CAAR,CAJqC;;EAMrC,MAAM+I,eAAe,GAAG,SAAlBA,eAAkB,GAAM;EAC5B;EACA;EACA;EACAC,IAAAA,OAAO,CAACC,GAAR,CAAY,QAAZ,EAJ4B;EAM5B;;EACAjJ,IAAAA,EAAE,CAAC2I,OAAH,CAAW3I,EAAE,CAACkJ,OAAH,EAAX;EACD,GARD,CANqC;;;EAiBrC,MAAI9D,OAAJ,CAAYpF,EAAZ,EAAgB+I,eAAhB,EAAiC,YAAM,EAAvC,EACG,IADH;EAGAD,EAAAA,QAAQ,CAAC9I,EAAD,EAAK,SAAL,CAAR,CApBqC;EAwBtC;EAGM,SAAS8I,QAAT,CAAkB9I,EAAlB,EAAsBzD,IAAtB,EAA4B;EAAE;EACnC,MAAI4M,QAAQ,GAAGnJ,EAAE,CAACE,QAAH,CAAY3D,IAAZ,CAAf,CADiC;;EAEjC,MAAI4M,QAAJ,EAAc;EACZ,SAAK,IAAI/J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+J,QAAQ,CAAC9J,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;EAAE;EAC1C+J,MAAAA,QAAQ,CAAC/J,CAAD,CAAR,CAAYoB,IAAZ,CAAiBR,EAAjB,EADwC;EAEzC;EACF;EACF;;ECzCM,SAASoJ,SAAT,CAAmBV,GAAnB,EAAwB;EAE7B;EACAA,EAAAA,GAAG,CAACvL,SAAJ,CAAckM,KAAd,GAAsB,UAAU1M,OAAV,EAAmB;EACvC;EACA,QAAMqD,EAAE,GAAG,IAAX,CAFuC;;EAIvCA,IAAAA,EAAE,CAACE,QAAH,GAAc1D,YAAY,CAACwD,EAAE,CAACsJ,WAAH,CAAe3M,OAAhB,EAAyBA,OAAzB,CAA1B,CAJuC;;EAMvCmM,IAAAA,QAAQ,CAAC9I,EAAD,EAAK,cAAL,CAAR,CANuC;;EAOvCD,IAAAA,SAAS,CAACC,EAAD,CAAT,CAPuC;;EASvC8I,IAAAA,QAAQ,CAAC9I,EAAD,EAAK,SAAL,CAAR,CATuC;EAUvC;;EACA,QAAIA,EAAE,CAACE,QAAH,CAAY6D,EAAhB,EAAoB;EAAE;EACpB/D,MAAAA,EAAE,CAACuJ,MAAH,CAAUvJ,EAAE,CAACE,QAAH,CAAY6D,EAAtB;EACD;EACF,GAdD;;EAeA2E,EAAAA,GAAG,CAACvL,SAAJ,CAAcoM,MAAd,GAAuB,UAAUxF,EAAV,EAAc;EAAE;EACrC,QAAM/D,EAAE,GAAG,IAAX;EACA+D,IAAAA,EAAE,GAAG/D,EAAE,CAAC4I,GAAH,GAASd,QAAQ,CAAC0B,aAAT,CAAuBzF,EAAvB,CAAd,CAFmC;EAInC;;EACA,QAAM9D,IAAI,GAAGD,EAAE,CAACE,QAAhB;;EAEA,QAAI,CAACD,IAAI,CAACsE,MAAV,EAAkB;EAChB,UAAIF,QAAQ,GAAGpE,IAAI,CAACoE,QAApB;;EACA,UAAI,CAACA,QAAD,IAAaN,EAAjB,EAAqB;EAAE;EACrBM,QAAAA,QAAQ,GAAGN,EAAE,CAAC0F,SAAd;EACAT,QAAAA,OAAO,CAACC,GAAR,CAAY5E,QAAZ;EACD;;EAED,UAAME,MAAM,GAAGH,kBAAkB,CAACC,QAAD,CAAjC;EACApE,MAAAA,IAAI,CAACsE,MAAL,GAAcA,MAAd,CARgB;EASjB,KAhBkC;;;EAoBnCsE,IAAAA,cAAc,CAAC7I,EAAD,CAAd,CApBmC;EAqBpC,GArBD;EAuBD;;EC/CM,SAAS0J,eAAT,CAAyB1H,IAAzB,EAA+B;EAClC,SAAO6F,KAAK,CAAC1D,SAAD,EAAYA,SAAZ,EAAuBA,SAAvB,EAAkCA,SAAlC,EAA6CnC,IAA7C,CAAZ;EACH;EACM,SAAS+F,aAAT,CAAuBvG,GAAvB,EAAoD;EAAA,MAAxB5C,IAAwB,uEAAjB,EAAiB;;EAAA,oCAAV6C,QAAU;EAAVA,IAAAA,QAAU;EAAA;;EACvD;EAGA,SAAOoG,KAAK,CAACrG,GAAD,EAAM5C,IAAN,EAAYA,IAAI,CAAChC,GAAjB,EAAsB6E,QAAtB,CAAZ;EACH;EAED;;EACA,SAASoG,KAAT,CAAerG,GAAf,EAAoB5C,IAApB,EAA0BhC,GAA1B,EAA+B6E,QAA/B,EAAyCO,IAAzC,EAA+C;EAC3C,SAAO;EACHR,IAAAA,GAAG,EAAHA,GADG;EAEH5C,IAAAA,IAAI,EAAJA,IAFG;EAGHhC,IAAAA,GAAG,EAAHA,GAHG;EAIH6E,IAAAA,QAAQ,EAARA,QAJG;EAKHO,IAAAA,IAAI,EAAJA;EALG,GAAP;EAOH;;ECjBM,SAAS2H,WAAT,CAAqBjB,GAArB,EAA0B;EAC/BA,EAAAA,GAAG,CAACvL,SAAJ,CAAcyM,EAAd,GAAmB,UAAU5H,IAAV,EAAgB;EACjC;EACA,WAAO0H,eAAe,CAAC1H,IAAD,CAAtB;EACD,GAHD;;EAIA0G,EAAAA,GAAG,CAACvL,SAAJ,CAAc0M,EAAd,GAAmB,YAAY;EAC7B,WAAO9B,aAAa,MAAb,SAAiB+B,SAAjB,CAAP;EACD,GAFD;;EAGApB,EAAAA,GAAG,CAACvL,SAAJ,CAAc4M,EAAd,GAAmB,UAAUC,GAAV,EAAe;EAChC;EACA,WAAOA,GAAG,IAAI,IAAP,GAAc,EAAd,GAAoB,QAAOA,GAAP,MAAe,QAAf,GAA0B9G,IAAI,CAACC,SAAL,CAAe6G,GAAf,CAA1B,GAAgDA,GAA3E;EACD,GAHD;;EAIAtB,EAAAA,GAAG,CAACvL,SAAJ,CAAc+L,OAAd,GAAwB,YAAY;EAClC;EAEA,QAAMlJ,EAAE,GAAG,IAAX;EAHkC,QAI3BuE,MAJ2B,GAIjBvE,EAAE,CAACE,QAJc,CAI3BqE,MAJ2B;EAOlC,QAAIsD,KAAK,GAAGtD,MAAM,CAAC/D,IAAP,CAAYR,EAAZ,CAAZ,CAPkC;;EAQlC,WAAO6H,KAAP;EACD,GATD;EAUD;;ECxBD;EAGO,SAASoC,aAAT,CAAuBvB,GAAvB,EAA4B;EAAE;EACnCA,EAAAA,GAAG,CAAC/L,OAAJ,GAAc,EAAd,CADiC;EAGjC;;EAEA+L,EAAAA,GAAG,CAACwB,KAAJ,GAAY,UAAUA,KAAV,EAAiB;EAC3B,SAAKvN,OAAL,GAAeH,YAAY,CAAC,KAAKG,OAAN,EAAeuN,KAAf,CAA3B;EACAlB,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKtM,OAAjB;EACD,GAHD;EAID;;ECHD;;EACA,SAAS+L,GAAT,CAAa/L,OAAb,EAAsB;EACpBqM,EAAAA,OAAO,CAACC,GAAR,CAAYtM,OAAZ,EADoB;;EAGpB,OAAK0M,KAAL,CAAW1M,OAAX,EAHoB;;EAIrB;;;EAGDyM,SAAS,CAACV,GAAD,CAAT;;EACAiB,WAAW,CAACjB,GAAD,CAAX;EACAD,cAAc,CAACC,GAAD,CAAd;;EAIAuB,aAAa,CAACvB,GAAD,CAAb;EACAA,GAAG,CAACvL,SAAJ,CAAcgN,SAAd,GAA0BrF,QAA1B;;;;;;;;"}